import os
import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Optional, Dict, List

import httpx
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from apscheduler.schedulers.asyncio import AsyncIOScheduler

# Configura√ß√£o
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("sentinel")

PORT = int(os.getenv("PORT", 8000))

# Inst√¢ncia global do scheduler
scheduler = AsyncIOScheduler()

class SentinelCore:
    def _init_(self):
        self.price_cache: Dict[str, dict] = {}
        self.news_cache: List[dict] = []
        self.ws_clients: List[WebSocket] = []
        self._initialized = False
    
    async def initialize(self):
        """Inicializa√ß√£o ass√≠ncrona"""
        if self._initialized:
            return
        
        scheduler.start()
        scheduler.add_job(self._update_prices, "interval", seconds=5)
        
        # Primeira atualiza√ß√£o
        await self._update_prices()
        await self._update_news()
        
        self._initialized = True
        logger.info("‚úÖ Sentinel iniciado com sucesso!")
    
    async def _update_prices(self):
        """Busca pre√ßos da Bybit"""
        try:
            async with httpx.AsyncClient() as client:
                symbols = [
                    "BTCUSDT", "ETHUSDT", 
                    "EURUSDT", "GBPUSDT", 
                    "USDJPY", "AUDUSDT", 
                    "USDCAD", "XAUUSDT"
                ]
                
                for symbol in symbols:
                    try:
                        resp = await client.get(
                            f"https://api.bybit.com/v5/market/tickers?category=spot&symbol={symbol}",
                            timeout=10.0
                        )
                        data = resp.json()
                        
                        if data.get("retCode") == 0 and data.get("result", {}).get("list"):
                            ticker = data["result"]["list"][0]
                            self.price_cache[symbol] = {
                                "price": float(ticker["lastPrice"]),
                                "timestamp": int(ticker["ts"]),
                                "change_24h": float(ticker.get("price24hPcnt", 0)) * 100
                            }
                            logger.info(f"‚úÖ {symbol}: {ticker['lastPrice']}")
                        else:
                            logger.warning(f"‚ö†Ô∏è {symbol}: {data.get('retMsg', 'sem dados')}")
                            
                    except Exception as e:
                        logger.error(f"‚ùå Erro em {symbol}: {e}")
                
                # Notifica WebSockets
                await self._broadcast({
                    "type": "prices",
                    "data": self.price_cache
                })
                
        except Exception as e:
            logger.error(f"‚ùå Erro geral: {e}")
    
    async def _update_news(self):
        """Busca not√≠cias"""
        self.news_cache = [
            {"time": "14:30", "currency": "USD", "event": "Non-Farm Payrolls", "impact": "High"}
        ]
    
    async def _broadcast(self, message: dict):
        """Envia para WebSockets"""
        disconnected = []
        for ws in self.ws_clients:
            try:
                await ws.send_json(message)
            except:
                disconnected.append(ws)
        
        for ws in disconnected:
            if ws in self.ws_clients:
                self.ws_clients.remove(ws)
    
    def analyze(self, asset: str) -> dict:
        """An√°lise t√©cnica"""
        symbol_map = {
            "EUR/USD": "EURUSDT",
            "GBP/USD": "GBPUSDT", 
            "USD/JPY": "USDJPY",
            "BTC/USDT": "BTCUSDT",
            "ETH/USDT": "ETHUSDT",
            "AUD/USD": "AUDUSDT",
            "USD/CAD": "USDCAD",
            "XAU/USD": "XAUUSDT"
        }
        
        symbol = symbol_map.get(asset, asset.replace("/", "") + "USDT")
        price_data = self.price_cache.get(symbol)
        
        if not price_data:
            logger.warning(f"‚ùå Sem dados: {asset} ({symbol})")
            return {
                "asset": asset,
                "status": "offline",
                "message": f"Sem dados para {asset}",
                "symbol": symbol,
                "available_symbols": list(self.price_cache.keys()),
                "timestamp": datetime.now().isoformat()
            }
        
        price = price_data["price"]
        change = price_data["change_24h"]
        
        # RSI simplificado
        rsi = 50 - (change * 2)
        rsi = max(0, min(100, rsi))
        
        confluences = 0
        if rsi < 30 or rsi > 70:
            confluences += 1
        if abs(change) > 1:
            confluences += 1
        
        tiers = {2: ("FORTE", "üü¢"), 1: ("MODERADO", "üü°"), 0: ("FRACO", "üî¥")}
        tier, emoji = tiers.get(confluences, ("FRACO", "üî¥"))
        
        signal = None
        if tier == "FORTE":
            signal = {
                "direction": "CALL" if rsi < 50 else "PUT",
                "entry": price,
                "expiration": 5
            }
        
        return {
            "asset": asset,
            "price": price,
            "tier": tier,
            "emoji": emoji,
            "indicators": {"rsi": round(rsi, 1), "change_24h": round(change, 2)},
            "confluences": confluences,
            "signal": signal,
            "timestamp": datetime.now().isoformat()
        }

# Cria inst√¢ncia global
core = SentinelCore()

# Cria app FastAPI
app = FastAPI(
    title="Sentinel Tactical API",
    version="1.0.0"
)

# CORS - Permite todas as origens
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup_event():
    """Inicializa quando o servidor come√ßa"""
    await core.initialize()

@app.get("/")
async def root():
    return {
        "status": "online",
        "service": "Sentinel Tactical v1.0",
        "cache_size": len(core.price_cache),
        "initialized": core._initialized
    }

@app.get("/dashboard")
async def dashboard():
    return {
        "prices": core.price_cache,
        "news": core.news_cache,
        "assets": [
            {"name": "EUR/USD", "price": core.price_cache.get("EURUSDT", {}).get("price")},
            {"name": "GBP/USD", "price": core.price_cache.get("GBPUSDT", {}).get("price")},
            {"name": "BTC/USDT", "price": core.price_cache.get("BTCUSDT", {}).get("price")}
        ]
    }

@app.get("/analyze/{asset}")
async def analyze(asset: str):
    return core.analyze(asset)

@app.websocket("/ws")
async def websocket_endpoint(ws: WebSocket):
    await ws.accept()
    core.ws_clients.append(ws)
    try:
        while True:
            data = await ws.receive_text()
            msg = json.loads(data)
            if msg.get("action") == "subscribe":
                await ws.send_json({"type": "subscribed", "assets": msg.get("assets", [])})
    except WebSocketDisconnect:
        if ws in core.ws_clients:
            core.ws_clients.remove(ws)

if _name_ == "_main_":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=PORT)
